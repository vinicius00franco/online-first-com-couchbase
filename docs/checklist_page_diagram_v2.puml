@startuml ChecklistPage Class Diagram v2
' Legend (simple format for compatibility)
legend top left
  Symbol - Meaning
  «interface» - Interface
  «abstract» - Abstract class / State base
endlegend

package "UI Layer" as UI {
  class ChecklistPage {
    +ChecklistPage()
  }

  class _ChecklistPageState {
    -TextEditingController textController
    +toggleItemCompletion(item: ShoppingItemEntity): Future<void>
    +deleteItem(item: ShoppingItemEntity): void
    +editItem(item: ShoppingItemEntity): void
    +addItem(): Future<void>
    +initApp(): Future<void>
    +initState(): void
    +dispose(): void
    +build(context: BuildContext): Widget
  }

  ChecklistPage --> _ChecklistPageState : creates

  class InputWidget {
    -TextEditingController controller
    -VoidCallback onAddItem
    +InputWidget(controller, onAddItem)
    +build(context): Widget
  }

  class ListSectionWidget {
    -String title
    -List<ShoppingItemEntity> items
    -Function(int) onToggleCompletion
    -Function(int) onDeleteItem
    -Function(int) onEditItem
    -bool isFullyEmpty
    +ListSectionWidget(title, items, onToggleCompletion, onDeleteItem, onEditItem, isFullyEmpty)
    +build(context): Widget
  }

  _ChecklistPageState --> InputWidget : uses
  _ChecklistPageState --> ListSectionWidget : uses
}

package "Logic Layer" as Logic {
  ' Unified cubit option
  interface ChecklistCubitAPI {
    +fetchItems(): Future
    +addItem(item: ShoppingItemEntity): Future
    +updateItem(id: String, title: String, isCompleted: bool): Future
    +deleteItem(id: String): Future
  }

  class ChecklistCubit {
    -IChecklistRepository _repository
    +ChecklistCubit(repository)
    +fetchItems(): Future
    +addItem(item: ShoppingItemEntity): Future
    +updateItem(id, title, isCompleted): Future
    +deleteItem(id): Future
  }

  ' Declare that the UI depends on the abstraction (ChecklistCubitAPI)
  _ChecklistPageState --> ChecklistCubitAPI : uses
  ' Grouped states for the cubit
  package "States" {
    ' Fetch-related states
    abstract class FetchChecklistState

    class FetchChecklistLoading
    class FetchChecklistLoaded {
      -items : List
      +FetchChecklistLoaded(items)
    }
    class FetchChecklistError {
      -message : String
      +FetchChecklistError(message)
    }

    FetchChecklistState <|-- FetchChecklistLoading
    FetchChecklistState <|-- FetchChecklistLoaded
    FetchChecklistState <|-- FetchChecklistError

    ' Action-related states
    ' Action-related states (generic, reusable)
    abstract class ActionState
    class ActionInitial
    class ActionLoading
    class ActionSuccess {
      -message : String (optional)
      -item : ShoppingItemEntity (optional)
      +ActionSuccess(message, item)
    }
    class ActionError {
      -message : String
      +ActionError(message)
    }

    ChecklistCubit --> FetchChecklistState : emits
    ChecklistCubit --> ActionState : emits
  }
}

package "Data Layer" as Data {
  ' Interface for repository
  interface IChecklistRepository {
    +fetchAll(): Future
    +addItem(item: ShoppingItemEntity): Future
    +updateItem(id: String, title: String, isCompleted: bool): Future
    +deleteItem(id: String): Future
  }

  class ChecklistRepository {
    -couchbaseService : CouchbaseService
    -collectionName : String
    +ChecklistRepository(couchbaseService)
    +fetchAll(): Future
    +addItem(item: ShoppingItemEntity): Future
    +updateItem(id, title, isCompleted): Future
    +deleteItem(id): Future
  }

  IChecklistRepository <|.. ChecklistRepository

  ' Couchbase service public API vs infra
  package "CouchbaseService (API)" as CBAPI {
    class CouchbaseService {
      +init(): Future
      +startReplication(onSynced: Function): Future
      +networkStatusListen(): void
      +add(data: Map, collectionName: String): Future
      +fetch(collectionName: String, filter: String): List
      +edit(collectionName: String, id: String, data: Map): Future
      +delete(collectionName: String, id: String): Future
    }
  }

  package "CouchbaseService (infra)" as CBInfra {
    class _DatabaseInfra {
      -databaseImpl
      -replicatorImpl
      -networkSubscription
    }
  }

  ChecklistRepository o-- CouchbaseService : composition
  CouchbaseService ..> _DatabaseInfra : uses

  ChecklistCubit --> ChecklistRepository : uses

  ' Implementation relationship: ChecklistCubit implements the API
  ChecklistCubitAPI <|.. ChecklistCubit
}

package "Entities" as Entities {
  class ShoppingItemEntity {
    -id : String (optional)
    -title : String
    -createdAt : DateTime
    -isCompleted : bool
    +ShoppingItemEntity(title, id, createdAt, isCompleted)
    +copyWith(...): ShoppingItemEntity
    +toMap(): Map
    +fromMap(data): ShoppingItemEntity
    +equals()/hashCode()
  }
}

' multiplicities
ListSectionWidget "items : 0..*" -- ShoppingItemEntity : contains
_ChecklistPageState --> ShoppingItemEntity : uses

' Suggestion: optional unified cubit
'' The unified ChecklistCubit now implements ChecklistCubitAPI (see above)

@enduml
